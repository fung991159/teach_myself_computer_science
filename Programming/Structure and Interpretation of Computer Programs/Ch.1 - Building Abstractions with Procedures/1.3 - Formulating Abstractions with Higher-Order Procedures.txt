Comment:
    1. higher-order procedures: procedures that manipulate procedures, 
    either accept procedures as arguments or return procedures as values.
    

Exercise 1.29. Simpson's Rule is a more accurate method of numerical integration than the method
illustrated above. Using Simpson's Rule, the integral of a function f between a and b is approximated as
where h = (b - a)/n, for some even integer n, and yk = f(a + kh). (Increasing n increases the accuracy of the
approximation.) Define a procedure that takes as arguments f, a, b, and n and returns the value of the
integral, computed using Simpson's Rule. Use your procedure to integrate cube between 0 and 1 (with n =
100 and n = 1000), and compare the results to those of the integral procedure shown above.

Exercise 1.30. The sum procedure above generates a linear recursion. The procedure can be rewritten so
that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the
following definition:
(define (sum term a next b)
    (define (iter a result)
        (if (a > b)
            result
            (iter (next a) (+ result term a))))
    (iter a 0)
)
! correct~

Exercise 1.31.
a. The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as
higher-order procedures.Write an analogous procedure called product that returns the product of the
values of a function at points over a given range. Show how to define factorial in terms of product.
Also use product to compute approximations to using the formula
>>
(define (product term a next b)
    (if (> a b)
        0
    (* (term a)
        (product term (next a) (next b))
    )
)
>> Show how to define factorial in terms of product.
>> term = factorial, a = bigger number, next= -1 instead of +1, b = 1
(define (factorial num)
    (product factorial num next 1)
)
!! I revesed the step from end to beginning, but it still works, just differently ;)
!! though base case should be 1, because anything multiple by 0 is 0, undoing all previous result


b. If your product procedure generates a recursive process, write one that generates an iterative process.
If it generates an iterative process, write one that generates a recursive process.

>> iterative process
(define (product term a next b)
    (define iter a result)
        (if (> a b)
            result
            (iter (next a) (* result term a))
        )
    (iter a 0)
)
! same here, base case should be 1


Exercise 1.32. a. Show that sum and product (exercise 1.31) are both special cases of a still more
general notion called accumulate that combines a collection of terms, using some general accumulation
function:

(accumulate combiner null-value term a next b)

Accumulate takes as arguments the same term and range specifications as sum and product, together
with a combiner procedure (of two arguments) that specifies how the current term is to be combined
with the accumulation of the preceding terms and a null-value that specifies what base value to use
when the terms run out. Write accumulate and show how sum and product can both be defined as
simple calls to accumulate.

(define accumulate combiner null-value term a next b
    (define combiner pre_term curr_term
        (+ acc_pre_terms curr_term)
    )
    (define iter a result)
        (if (> a b)
            null-value
            (iter (next a) (* result term a))
            )
        (iter a 0)
)
>> no clue on how combiner are defined

!! this looks surprisingly simple (as usual), got the null-value part right,
but not the combiner...so combiner is actually a operator...

(define (accumulate combiner null-value term a next b) 
    (if (> a b) 
        null-value 
        (combiner (term a) (accumulate combiner null-value term (next a) next b)))) 


Exercise 1.33. You can obtain an even more general version of accumulate (exercise 1.32) by
introducing the notion of a filter on the terms to be combined. That is, combine only those terms derived
from values in the range that satisfy a specified condition. The resulting filtered-accumulate
abstraction takes the same arguments as accumulate, together with an additional predicate of one argument
that specifies the filter. Write filtered-accumulate as a procedure. Show how to express the
following using filtered-accumulate:

(define filtered-accumulate combiner null-value term a next b filter
    (if (filter a) 
        null-value 
        (combiner (term a) (accumulate combiner null-value term (next a) next b)))) 
)
a. the sum of the squares of the prime numbers in the interval a to b (assuming that you have a prime?
predicate already written)

>>(filtered-accumulate + 0 square a next b is-prime)

b. the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers i
< n such that GCD(i,n) = 1).

>>(filtered-accumulate * 0 square a next n is-prime)
>> doesn't really understand this question