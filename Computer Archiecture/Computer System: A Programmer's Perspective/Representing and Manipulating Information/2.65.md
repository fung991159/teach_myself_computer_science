Write code to implement the following function:
/* Return 1 when x contains an odd number of 1s; 0 otherwise.
Assume w=32 */
int odd_ones(unsigned x);
Your function should follow the bit-level integer coding rules (page 164),
except that you may assume that data type int has w = 32 bits.
Your code should contain a total of at most 12 arithmetic, bitwise, and logical
operations.

> I have no idea how this functions works. Most of the online resource just post
> the answer without any explanation. 
>
> The only thing I can see is the shift operation preserve original x value into
> the right most bits, but I don't understand how the folding operation
> works....... to be revisit later.

```
int odd_ones(unsigned x)
{
    show_bytes((byte_pointer)&x, sizeof(x)); // 0x12345678

    x ^= x >> 16;
    show_bytes((byte_pointer)&x, sizeof(x)); // 0x12345678 ^ 0x00001234 = 0x12344444

    x ^= x >> 8;
    show_bytes((byte_pointer)&x, sizeof(x)); // 0x12344444 ^ 0x00123444 = 0x12220000
    x ^= x >> 4;
    show_bytes((byte_pointer)&x, sizeof(x)); // 0x12220000 ^ 0x01222000 = 0x11000000
    x ^= x >> 2;
    show_bytes((byte_pointer)&x, sizeof(x)); // 0x11000000 ^ 0x01100000 = 0x10100000
    x ^= x >> 1;
    show_bytes((byte_pointer)&x, sizeof(x));           // 0x10100000 ^ 0x01010000 = 0x11110000
    unsigned output = x & 1;                           // 0x11110000 & 0x00000001 = 0x00000000
    show_bytes((byte_pointer)&output, sizeof(output)); // 0x11110000 & 0x00000001 = 0x00000000
    return output;
};
```