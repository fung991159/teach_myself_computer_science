For the C code
```c
short dw_loop(short x) {
  short y = x/9;
  short *p = &x;
  short n = 4*x;
  do {
    x += y;
    (*p) += 5;
    n -= 2;
  } while (n > 0);
  return x;
}
```

short dw_loop(short x)
x initially in %rdi

%rdx = n
%rcx = y
```assembly
gcc generates the following assembly code:
 dw_loop:
  movq %rdi, %rbx     // tmp = x
  movq %rdi, %rcx     // y = x
  idivq $9, %rcx      // y / 9
  leaq (,%rdi,4), %rdx  // n = 4 * x
 .L2:
  leaq 5(%rbx,%rcx), %rcx   // 5+
  subq $1, %rdx
  testq %rdx, %rdx
 jg .L2
 rep; ret

```

A. Which registers are used to hold program values x, y, and n?


B. How has the compiler eliminated the need for pointer variable p and the
pointer dereferencing implied by the expression (*p)+=5?
C. Add annotations to the assembly code describing the operation of the pro-
gram, similar to those shown in Figure 3.19(c).